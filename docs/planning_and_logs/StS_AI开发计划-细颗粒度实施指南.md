# 杀戮尖塔（Slay the Spire）AI 开发计划 — 细颗粒度实施指南

> 目标：在本地（Mac Mini M4 16GB）开发针对 StS 的小型 AI 模型，从「能自动玩一局」到「可训练、可扩展」，最终可冲击 A20 连胜。  
> **终极目标：NoSL 盗贼（静默猎手）28 连胜，超越人类 NoSL 盗贼 27 连胜纪录。**  
> 本文档为完整执行计划，按顺序执行即可。

---

## 一、先澄清几件事（减少“云里雾里”）

### 1. 要不要找杀戮尖塔的 Mod？**要。**

- **原因**：AI 需要知道「当前局面」（手牌、费用、敌人意图、血量等）。Steam 原版游戏**没有**对外提供这些数据，只能通过 **Mod** 在游戏内部读取并暴露出来。
- **用什么**：
  - **ModTheSpire**：StS 的 Mod 框架，绝大多数 Mod 都基于它。
  - 在此基础上，你需要：**要么**用一个**已经能暴露游戏状态的 Mod**（若有现成的），**要么**自己写一个很小的 Mod，在每回合把「状态」写到文件或通过本地网络发给你的 Python。

### 2. 跑 AI 是不是必须从 Steam 里打开游戏？**分两种方式。**

| 方式 | 是否需要开 Steam 里的 StS | 说明 |
|------|----------------------------|------|
| **A. 真机方案**（推荐你先做这个） | **要**。从 Steam 启动 StS，在 StS 里加载 ModTheSpire + 你的状态 Mod。你的 Python 脚本在电脑上另开一个进程，通过「读 Mod 写的文件」或「连 Mod 开的本地端口」拿到状态，再通过**模拟键鼠**把操作发给游戏。 | 你 1000+ 小时的经验完全用得上，且不用搞「游戏模拟器」，先打通一条能自动玩、能记日志的链路。 |
| **B. 模拟器方案** | **不要**。有人做过 StS 的「无界面模拟器」（如基于 sts_lightspeed 等），用代码模拟战斗，不启动 Steam 游戏。 | 训练快，但需要额外找/搭环境，适合后面规模训练时再考虑。 |

**结论**：

- 你现在**以「真机方案」为主**：**需要从 Steam 打开杀戮尖塔**，在游戏里用 Mod 提供状态，外面用 Python 读状态、算决策、模拟键鼠。
- 「跑 AI 模型」可以有两种含义：
  - **玩游戏/收集数据**：必须开着 StS（Steam 启动即可）。
  - **训练模型**：可以在「游戏关掉」的情况下跑——例如用已经收集好的战斗日志在 Python 里训练；若用真机边玩边训，则训练时游戏也要开着。

### 3. 概念对应表（方便对照）

| 你可能会想的问题 | 对应概念 |
|------------------|----------|
| 「AI 怎么知道现在有什么牌？」 | **游戏状态**：由 Mod 在游戏内部读取（手牌、费用、敌人意图、血量等），写到文件或发到本地端口，Python 再读。 |
| 「AI 怎么出牌？」 | **动作**：Python 根据当前状态算「该出哪张牌/点哪里」，再通过 **模拟键鼠**（如 pyautogui）点击游戏窗口里的牌、敌人等。 |
| 「训练数据从哪来？」 | **战斗日志**：每回合 Mod 或 Python 记录「当前状态 + 本回合出的牌 + 结果」，存成 JSON/CSV，这些就是「训练数据」。 |
| 「什么时候训练模型？」 | 先攒够一批**带日志的对局**（可以先用规则/随机出牌），再在 Python 里用这些日志训练一个小网络；或后面接 RL，让 AI 自己打很多局再训练。 |
| 「Mod 和 Steam 的关系？」 | Steam 只负责**启动 StS**；Mod 是**装在 StS 游戏目录下**的，用 ModTheSpire 加载，游戏启动后 Mod 在游戏里跑，和 Steam 无关（除了通过 Steam 启动游戏）。 |

---

## 二、阶段 0：环境与 Mod（目标：能从游戏里拿到「状态」，并能用 Python 发键鼠）

**完成标准**：从 Steam 打开 StS，进一场战斗，Python 能**持续读到当前状态**，并能**用脚本发送键鼠**让角色出牌（哪怕只是固定顺序），即「真机方案」打通。

| 步骤编号 | 具体动作 | 说明 / 注意 |
|----------|----------|-------------|
| **0.1** | 确认 StS 安装路径 | 在 Steam 里右键 StS → 管理 → 浏览本地文件，记下路径（例如 `.../Steam/steamapps/common/SlayTheSpire`）。 |
| **0.2** | 安装 ModTheSpire | 从 ModTheSpire 官方/GitHub 下载最新 release，把 jar 放到 StS 根目录（或按官方说明放）；用 Steam 启动 StS 时加参数 `-jar ModTheSpire.jar`，或使用其提供的启动器。确认游戏能正常启动且 Mod 菜单里能看到 ModTheSpire。 |
| **0.3** | 查找或选定「状态暴露」方案 | 在 Steam 创意工坊或 GitHub 搜索「Slay the Spire mod API」「ModTheSpire base mod」「game state export」等，看是否有现成 Mod 能把当前战斗状态写出文件或发到端口；若有，安装并启用；若没有，则计划在 0.4 写一个最小 Mod（只写当前手牌、费用、敌人意图、己方/敌人血量到 JSON 文件）。 |
| **0.4** | 实现「状态可读」 | 若用现成 Mod：按该 Mod 文档配置输出路径/端口，确认每回合或每步能生成一个状态文件或可连接端口。若自己写 Mod：在 ModTheSpire 里写一个最小逻辑，在每回合开始或结束时把上述状态写入一个固定路径的 JSON 文件（例如 `sts_state.json`），供 Python 读取。 |
| **0.5** | Python 环境 | 在本机安装 Python 3，在项目目录 `AI_THE_SPIRE` 下用 venv 创建虚拟环境，安装 `pyautogui`、`pynput`（或你熟悉的键鼠库）以及后续要用的 `numpy`、`torch` 等（可后续按需装）。 |
| **0.6** | 「读状态」脚本 | 写一个 Python 脚本（如 `read_state.py`）：循环读取 Mod 写入的状态文件（或连接 Mod 提供的本地端口），解析 JSON，在控制台打印「当前手牌、费用、敌人意图、血量」。用 Steam 启动 StS，进一局战斗，手动触发 Mod 写状态，确认 Python 能稳定读到与游戏一致的数据。 |
| **0.7** | 「发键鼠」脚本 | 写一个 Python 脚本（如 `send_input.py`）：根据你游戏内的键位（如数字键选牌、空格确认等），用 pyautogui/pynput 发送按键或点击。先做「固定序列」（例如每 2 秒按一次 1、空格），在 StS 窗口在前台时运行，确认游戏有反应。 |
| **0.8** | 窗口与焦点 | 确定策略：训练/自动玩时 StS 窗口是否始终前台、分辨率是否固定。若固定分辨率，后续「点击坐标」可写死或从配置文件读；若需兼容多分辨率，可后续再加「截屏 + 识别按钮/牌位置」（可放在阶段 2 之后）。 |

---

## 三、阶段 1：战斗日志与「固定牌组 + 固定敌人」的数据管线（目标：有可训练的战斗数据）

**完成标准**：你有一批**格式统一、可解析**的「静默 vs Jaw Worm」战斗日志，且你本人能看懂每一条对应「哪一回合出了什么牌、结果如何」。

| 步骤编号 | 具体动作 | 说明 / 注意 |
|----------|----------|-------------|
| **1.1** | 定义日志格式 | 设计一个 JSON 结构（或 CSV）：每回合至少包含「回合号、手牌列表（牌 ID 或名称）、费用、敌人意图、本回合出的牌及顺序、回合结束时己方/敌人血量」。确定保存路径（如 `combat_logs/`），每局一个文件或每回合追加。 |
| **1.2** | 在 Mod 或 Python 中实现写日志 | 若 Mod 方便写文件：在 Mod 里每回合写入上述字段。若 Mod 只写状态：则在 Python 里根据「上一状态 + 当前状态 + 发送过的动作」推断本回合出的牌，写入日志。优先保证「出的牌、结果血量」准确。 |
| **1.3** | 固定「静默 vs Jaw Worm」 | 通过 Mod 或手动操作，反复进入「静默猎手、第一层、第一个小怪为 Jaw Worm」的战斗（可用种子或选路实现）。用阶段 0 的「读状态 + 发键鼠」，用**简单规则**出牌（例如「有费就优先打攻击」），打 50～100 场，每场都记完整 combat log。 |
| **1.4** | 检查日志质量 | 随机抽几条日志，对照游戏回放或记忆，确认：手牌、出的牌、最终血量与实际情况一致。若有错，回到 1.2 修正写入逻辑。 |

---

## 四、阶段 2：第一个可训练的「战斗决策」小模型（目标：有一个能学「出牌」的模型，参数量小、本地可训）

**完成标准**：你有一个**只针对「静默 vs Jaw Worm」**的小模型，能在本地用日志训练，并能（可选）在 Steam 打开的 StS 里自动出牌打完这一种战斗。

| 步骤编号 | 具体动作 | 说明 / 注意 |
|----------|----------|-------------|
| **2.1** | 把日志转成「状态-动作」对 | 写脚本：读取阶段 1 的 JSON/CSV，对每一回合生成一条样本：**输入** = 该回合开始时的状态（手牌、费用、敌人意图、血量等，编码成固定长度向量）；**输出** = 该回合实际出的牌（或离散动作 ID）。输出保存为 numpy 数组或 PyTorch Dataset 可读格式。 |
| **2.2** | 定义状态/动作空间 | 状态：手牌 one-hot 或 ID 序列 + 标量（费用、己方血、敌人血等），长度固定，例如 100～500 维。动作：离散，例如「出牌组合 A/B/C/...」或「第 1 张牌、第 2 张牌…」，动作数在几十到一两百即可。 |
| **2.3** | 建一个 2～3 层 MLP | 输入维 = 状态维，输出维 = 动作数（或多分类），参数量控制在几十万级（例如 2 层 256 隐藏）。用 PyTorch 或你熟悉的框架，写前向传播和交叉熵损失（若动作为离散）。 |
| **2.4** | 用阶段 1 数据做监督学习 | 用 2.1 的数据训练 2.3 的 MLP：输入状态 → 预测动作，损失为预测动作与日志中「真实动作」的交叉熵。训练几个 epoch，在「留出的一小部分日志」上看准确率或 top-3 准确率。 |
| **2.5** | 用训练好的模型驱动游戏（可选） | 在阶段 0 的循环里：读状态 → 用 2.3 模型推理得到动作 → 通过键鼠执行。在同样的「静默 vs Jaw Worm」下跑若干局，看胜率/剩余血量是否比「纯规则」好。若明显不好，回到 2.1～2.4 检查数据质量和网络大小。 |

---

## 五、阶段 3：扩展到多敌人、多战、简单路线（目标：能自动打完第 1 层，并开始 RL 或更大规模监督学习）

| 步骤编号 | 具体动作 | 说明 / 注意 |
|----------|----------|-------------|
| **3.1** | 扩展状态/动作 | 状态里加入「敌人类型」「当前层/节点」等；动作若涉及路线选择，增加「选哪条路」的离散动作。日志格式同步扩展，新打的局都带这些字段。 |
| **3.2** | 自动打完第 1 层 | 用 Mod 或固定种子/路线，让脚本能自动「选路 → 进入战斗 → 读状态 → 决策（规则或阶段 2 的模型）→ 发键鼠 → 记录日志 → 下一战」，直到 Boss 或死亡。先保证流程稳定，再谈胜率。 |
| **3.3** | 引入 RL（可选） | 若你希望「从胜负学」而不是只从日志模仿：用 Stable-Baselines3 等，把「StS 真机」包成一个 RL 环境（reset = 开新局/进战斗，step = 发动作、读下一状态、给奖励）。奖励 = 每战剩余血 + 通关层奖励。训练时仍需要**从 Steam 打开 StS**，让环境在后台或前台跑对局；或先用阶段 1～2 的日志做模仿学习，再在真机上做少量 RL 微调。 |
| **3.4** | 7×24 与资源 | 若在 Mac Mini 上 7×24 跑：用阶段 0 的「真机方案」时，StS 需长时间开着，可设成无音、最小化；训练脚本和游戏可同一台机，注意散热。若后面用「模拟器方案」，则训练可完全在后台，不依赖 Steam 是否打开。 |

---

## 六、实施检查清单（按顺序执行）

按此清单逐项打勾，完成一项再进下一项。

- [ ] **1.** 在 Steam 中找到 StS 本地安装路径并记录。
- [ ] **2.** 下载并安装 ModTheSpire，确认能从 Steam 启动带 Mod 的 StS。
- [ ] **3.** 确定「状态暴露」方案：安装现成 Mod 或自己写最小 Mod，把当前战斗状态写入 JSON 或发到本地端口。
- [ ] **4.** 实现并验证：Mod 在每回合（或每步）能稳定输出状态到指定路径/端口。
- [ ] **5.** 在本机创建 Python 项目目录与 venv，安装 pyautogui、pynput 及后续需要的库。
- [ ] **6.** 编写并运行「读状态」脚本，在 Steam 启动 StS 并进入一场战斗时，确认 Python 能持续读到与游戏一致的状态。
- [ ] **7.** 编写并运行「发键鼠」脚本，在 StS 前台时能通过脚本发送按键/点击并让游戏有反应。
- [ ] **8.** 定义战斗日志的 JSON/CSV 格式（回合号、手牌、费用、敌人意图、本回合出牌、回合结束血量等）。
- [ ] **9.** 在 Mod 或 Python 中实现按该格式写入战斗日志。
- [ ] **10.** 固定「静默 vs Jaw Worm」，用规则出牌自动打 50～100 场并记录完整日志。
- [ ] **11.** 抽查日志，确认与真实对局一致，必要时修正写日志逻辑。
- [ ] **12.** 写脚本将日志转为「状态向量 + 动作」的训练数据。
- [ ] **13.** 定义状态向量维度和动作空间（离散动作列表）。
- [ ] **14.** 用 PyTorch（或其它框架）实现 2～3 层 MLP，输入=状态，输出=动作，参数量几十万级。
- [ ] **15.** 用转换后的数据训练该 MLP，在留出集上评估准确率/top-k。
- [ ] **16.** （可选）用训练好的模型在「静默 vs Jaw Worm」真机对局中自动出牌，观察胜率/血量。
- [ ] **17.** 扩展状态与日志格式以支持多敌人、层/节点；实现自动打完第 1 层的流程。
- [ ] **18.** （可选）将 StS 真机包成 RL 环境并接 Stable-Baselines3，或先用更多日志做模仿学习再考虑 RL。
- [ ] **19.** 若需 7×24 训练，配置 Mac Mini 上长时间运行 StS + 训练脚本的启动方式与资源占用。

---

## 七、参考与延伸

- **TwitchSlaysSpire**：有 AI 模拟战斗并选较优方案，能「作弊」看意图/抽牌/回滚，可作战斗求解或数据生成思路参考；FAQ 有文档链接。
- **sts_lightspeed**：有人用其与游戏状态交互，可查是否仍有维护，作为接游戏/模拟的现成基础之一。
- **社区建议**：从「固定牌组 vs 固定敌人」（如 Jaw Worm）开始，再扩展到多战、选牌、商店、路线；先建好战斗内行动日志，再谈训练。

---

## 八、设备与成本（简要）

- **设备**：Mac Mini M4 16GB 内存、256GB SSD，可 7×24 跑阶段 0～2 及小规模 RL；模型参数量在几十万～几百万级，无需 30B/70B 级大模型。
- **金钱成本**：本地训练几乎为零；若后续用云端 GPU 做大规模 RL，再按需预算。
- **时间成本**：阶段 0～1 约 1～2 周，阶段 2 约 2～4 周，阶段 3 视目标可长期迭代。

---

*文档版本：1.0 | 路径：/Volumes/T7/AI_THE_SPIRE/StS_AI开发计划-细颗粒度实施指南.md*
